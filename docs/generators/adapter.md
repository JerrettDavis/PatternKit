# Adapter Pattern Generator

The Adapter Pattern Generator automatically creates an object adapter class that implements a target interface by delegating to an adaptee instance. Mapping methods in a static host class define how each target member translates to adaptee operations.

## Overview

The generator produces:

- **Adapter class** implementing the target interface
- **Constructor** accepting the adaptee instance with null-check
- **Delegating methods** that call mapping methods with the stored adaptee reference
- **Throwing stubs** for unmapped members (when configured)
- **Diagnostics** for common mistakes (non-partial hosts, missing mappings, signature mismatches)
- **Zero runtime overhead** through source generation

## Quick Start

### 1. Define Target and Adaptee

```csharp
public interface IModernLogger
{
    void LogInfo(string message);
    void LogError(string message, Exception ex);
}

public class LegacyLogger
{
    public void Write(string level, string msg) { /* ... */ }
}
```

### 2. Create the Host with Mappings

```csharp
using PatternKit.Generators.Adapter;

[GenerateAdapter(Target = typeof(IModernLogger), Adaptee = typeof(LegacyLogger))]
public static partial class LoggerAdapterHost
{
    [AdapterMap(TargetMember = "LogInfo")]
    public static void LogInfo(LegacyLogger adaptee, string message)
        => adaptee.Write("INFO", message);

    [AdapterMap(TargetMember = "LogError")]
    public static void LogError(LegacyLogger adaptee, string message, Exception ex)
        => adaptee.Write("ERROR", $"{message}: {ex.Message}");
}
```

### 3. Build Your Project

The generator emits `LegacyLoggerToModernLoggerAdapter.Adapter.g.cs`:

```csharp
// <auto-generated />
#nullable enable

public sealed class LegacyLoggerToModernLoggerAdapter : IModernLogger
{
    private readonly LegacyLogger _adaptee;

    public LegacyLoggerToModernLoggerAdapter(LegacyLogger adaptee)
    {
        _adaptee = adaptee ?? throw new ArgumentNullException(nameof(adaptee));
    }

    public void LogInfo(string message)
    {
        LoggerAdapterHost.LogInfo(_adaptee, message);
    }

    public void LogError(string message, Exception ex)
    {
        LoggerAdapterHost.LogError(_adaptee, message, ex);
    }
}
```

### 4. Use It

```csharp
var legacy = new LegacyLogger();
IModernLogger logger = new LegacyLoggerToModernLoggerAdapter(legacy);
logger.LogInfo("Hello from the adapter!");
```

## Attributes

### `[GenerateAdapter]`

| Property | Type | Default | Description |
|---|---|---|---|
| `Target` | `Type` | (required) | Target interface or abstract class the adapter implements |
| `Adaptee` | `Type` | (required) | Adaptee type whose functionality is wrapped |
| `AdapterTypeName` | `string?` | `"{Adaptee}To{Target}Adapter"` | Name of the generated adapter class |
| `MissingMap` | `AdapterMissingMapPolicy` | `Error` | How to handle target members without mapping methods |

### `[AdapterMap]`

| Property | Type | Default | Description |
|---|---|---|---|
| `TargetMember` | `string?` | Method name | Name of the target member this method maps to |

When `TargetMember` is not specified, the generator matches by method name.

### `AdapterMissingMapPolicy`

| Value | Description |
|---|---|
| `Error` | Emit a diagnostic error for unmapped members (default) |
| `ThrowingStub` | Generate a stub that throws `NotImplementedException` |

## Diagnostics

| ID | Severity | Description |
|---|---|---|
| PKADP001 | Error | Host class must be both `static` and `partial` |
| PKADP002 | Error | Target must be an interface or abstract class |
| PKADP003 | Error | Missing mapping for a target member (when policy is Error) |
| PKADP004 | Error | Multiple mapping methods for the same target member |
| PKADP005 | Error | Mapping method return type does not match target member |
| PKADP006 | Error | Adapter type name conflicts with an existing type |

## Examples

### Name-Based Matching

When `TargetMember` is omitted, the generator matches mapping methods by name:

```csharp
public interface ITarget
{
    string Process(string input);
}

[GenerateAdapter(Target = typeof(ITarget), Adaptee = typeof(LegacySystem))]
public static partial class LegacyAdapterHost
{
    [AdapterMap] // Matches "Process" by method name
    public static string Process(LegacySystem adaptee, string input)
        => adaptee.OldProcess(input);
}
```

### ThrowingStub for Incremental Development

```csharp
[GenerateAdapter(
    Target = typeof(IFullApi),
    Adaptee = typeof(PartialImpl),
    MissingMap = AdapterMissingMapPolicy.ThrowingStub)]
public static partial class IncrementalAdapterHost
{
    [AdapterMap(TargetMember = "GetData")]
    public static string GetData(PartialImpl adaptee) => adaptee.FetchData();
    // Other methods get NotImplementedException stubs
}
```

### Custom Adapter Name

```csharp
[GenerateAdapter(
    Target = typeof(ITarget),
    Adaptee = typeof(Legacy),
    AdapterTypeName = "MyLegacyBridge")]
public static partial class LegacyHost { ... }
```

## Best Practices

1. **Keep mapping methods pure** -- they should only delegate to the adaptee, not maintain state.
2. **Use `TargetMember`** for explicit control when method names differ between target and host.
3. **Start with `ThrowingStub`** during development, then switch to `Error` before shipping.
4. **Register adapters in DI** for seamless integration with dependency injection containers.
5. **The first parameter** of each mapping method must be the adaptee type.

## See Also

- [Adapter Generator Example](../examples/adapter-generator-demo.md)
- [Structural Patterns](../patterns/structural/index.md)
