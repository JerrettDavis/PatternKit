# Singleton Pattern Generator

The Singleton Pattern Generator automatically creates a static `Instance` property that provides a single shared instance of a decorated class. It eliminates the boilerplate for eager and lazy initialization, thread safety, and optional factory methods.

## Overview

The generator produces:

- **Eager singleton** via a static property initializer (`public static T Instance { get; } = new T();`)
- **Lazy singleton** via `System.Lazy<T>` with configurable thread-safety modes
- **Factory method support** via `[SingletonFactory]` for custom construction logic
- **Diagnostics** for common mistakes (non-partial types, public constructors, name conflicts)
- **Zero runtime overhead** through source generation

## Quick Start

### 1. Mark Your Class

```csharp
using PatternKit.Generators.Singleton;

[Singleton]
public partial class AppClock
{
    private AppClock() { }

    public DateTime Now => DateTime.UtcNow;
}
```

### 2. Build Your Project

The generator emits `AppClock.Singleton.g.cs`:

```csharp
// <auto-generated />
#nullable enable

partial class AppClock
{
    public static AppClock Instance { get; } = new AppClock();
}
```

### 3. Use It

```csharp
var clock = AppClock.Instance; // Always the same instance
```

## Attributes

### `[Singleton]`

| Property | Type | Default | Description |
|---|---|---|---|
| `Mode` | `SingletonMode` | `Eager` | `Eager` or `Lazy` initialization |
| `Threading` | `SingletonThreading` | `ThreadSafe` | `ThreadSafe` or `SingleThreadedFast` (only applies to Lazy) |
| `InstancePropertyName` | `string` | `"Instance"` | Name of the generated static property |

### `[SingletonFactory]`

Marks a static, parameterless method as the factory for creating the singleton instance. When present, the generator calls this method instead of `new T()`.

```csharp
[Singleton(Mode = SingletonMode.Lazy)]
public partial class AppConfig
{
    private AppConfig(Dictionary<string, string> settings) { ... }

    [SingletonFactory]
    private static AppConfig LoadConfig()
    {
        var settings = LoadFromFile("config.json");
        return new AppConfig(settings);
    }
}
```

## Diagnostics

| ID | Severity | Description |
|---|---|---|
| PKSNG001 | Error | Type marked with `[Singleton]` must be `partial` |
| PKSNG002 | Error | Type marked with `[Singleton]` must be a class (not struct/record struct) |
| PKSNG003 | Error | No parameterless constructor or `[SingletonFactory]` method found |
| PKSNG004 | Error | Multiple `[SingletonFactory]` methods found |
| PKSNG005 | Warning | Type has a public constructor (consider making it private) |
| PKSNG006 | Error | Instance property name conflicts with an existing member |

## Examples

### Eager Singleton (Default)

```csharp
[Singleton]
public partial class Logger
{
    private Logger() { }
    public void Log(string message) => Console.WriteLine(message);
}

Logger.Instance.Log("hello"); // Eager: created at class-load time
```

### Lazy Thread-Safe Singleton

```csharp
[Singleton(Mode = SingletonMode.Lazy)]
public partial class DatabasePool
{
    private DatabasePool() { /* expensive setup */ }
}

var pool = DatabasePool.Instance; // Created on first access, thread-safe
```

### Lazy Single-Threaded (Performance)

```csharp
[Singleton(Mode = SingletonMode.Lazy, Threading = SingletonThreading.SingleThreadedFast)]
public partial class StartupConfig
{
    private StartupConfig() { }
}
// Only safe if you guarantee single-threaded access during init
```

### Custom Property Name

```csharp
[Singleton(InstancePropertyName = "Default")]
public partial class Serializer
{
    private Serializer() { }
}

Serializer.Default.Serialize(obj);
```

## Best Practices

1. **Make constructors private or internal** to prevent external instantiation. The generator warns (PKSNG005) about public constructors.
2. **Prefer Eager mode** for lightweight singletons -- it is simpler and has zero synchronization overhead.
3. **Use Lazy mode** when construction is expensive and the singleton may never be used in a given run.
4. **Use `[SingletonFactory]`** when construction requires parameters, configuration, or complex logic.
5. **Avoid mutable state** in singletons or protect shared state with proper synchronization.

## See Also

- [Singleton Generator Example](../examples/singleton-generator-demo.md)
- [Creational Patterns](../patterns/creational/index.md)
